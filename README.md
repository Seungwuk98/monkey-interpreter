# Monkey Interpreter

|밑바닥부터 시작하는 인터프리터 in Go|밑바닥부터 시작하는 컴파일러 in go|
|:---:|:---:|
|![](http://image.yes24.com/goods/103157156/L)|![](http://image.yes24.com/goods/103099817/L)|

본 리포지토리는 위 서적을 바탕으로 만들어졌음을 미리 밝힙니다. 

## 프로그램의 실행

`monkey` 파일은 인터프리터를 바이너리파일로 빌드한 것으로 두 가지 사용 방법이 있습니다. 

1. REPL
2. excute

파일을 실행하면 REPL 모드로 실행됩니다. 즉각적으로 원하는 값을 확인할 수 있습니다. 
```monkey
>> 1 + 2 * 3 + 4
11
>> let a = [1, 3, 5, 7]
>> a
[1, 3, 5, 7]
```

바이너리 파일의 인자로서 파일을 주면, 해당 파일을 실행합니다. 

- power.monkey 파일

```monkey
let a = 10;
puts(a);
```

```bash
$ ./monkey power.monkey
10
```



## let 문

```monkey
let a = 100;
let b = "abcd";
let c = [1, 2, "abcd", [1, 3, 5, 7], {"tt" : 30, 30 : "uu", 40 : [1, 5, 7, 8]}]
```

`let`을 이용하여 변수에 값을 바인딩할 수 있습니다. 타입은 `int`, `bool`, `list`, `hash`를 지원합니다.

### int

`int`는 64비트 정수만 지원하고 있습니다. 아직 추가 지원 계획은 없고, 혹 후에 추가한다면 파이썬처럼 `bigint`를 지원하는 방향으로 생각 중입니다. 연산자는 `+, -, /, <<, >>, ~, ^, &, |, <, >, <=, >=, ==, !=`를 지원하고 있습니다.

추가 계획 : 연산자 `%, **, ++, --`

### string

`string`은 쌍따옴표 `"`로 감싸서만 사용할 수 있습니다. `concat` 연산으로 `+`를 이용할 수 있습니다. 

추가 계획 : 

1. `*` 연산자 : 여러번 반복하는 문자열 생성
2. `[]` 연산자 : 아직 string의 원소를 접근하는 방법을 지원하지 않습니다. 후에 추가 계획입니다. 

### list

`list`는 `[`, `]`로 감싸서 사용할 수 있습니다. 타입은 검사하지 않으므로 모든 타입을 넣을 수 있습니다.  

현재 빌트인 함수로 `first`, `last`, `rest`, `push`, `len`를 사용할 수 있습니다. 

```monkey
arr = [1, 2, 3, 4]
puts(push(arr, 5))
puts(rest(arr))
puts(first(arr))
puts(last)
puts(len(arr))
```
결과는 아래와 같습니다. 
```monkey
[1, 2, 3, 4, 5]
[2, 3, 4]
1
4
4
```

### bool

`bool`은 특별한 것은 없습니다. `true`, `false`를 지원합니다. 부등호의 결과로 `true` 또는 `false`가 반환됩니다. 

추가 계획:

1. `monkey`에서 리스트는 불변 객체입니다만, 가변 객체로 변경 예정입니다. 
2. `*` 연산자 : `string` 계획과 마찬가지로 파이썬처럼 원소가 여러개 있는 객체를 생성하는 것을 추가할 계획입니다. 

### Hash

`Hash`는 파이썬의 `dictionary`, C++의 `map`와 유사합니다. 역시나 타입은 검사하지 않습니다. 단, 리스트는 `key`로 사용이 불가합니다. 

```monkey
let a = {1: "abcd", "monkey": "good"}
puts(a[1])
puts(a["monkey"])
```
결과는 아래와 같습니다. 

```monkey
abcd
good
```

추가 계획:

1. 아직까지 `Hash`를 다루는 편의 함수를 제공하지 않습니다. 추후 설계 및 구현을 진행할 예정입니다.


## if 문

`monkey`에서 `if`문은 표현식입니다. 이는 `ocaml`과 유사합니다. 

```monkey
let a = if (true) { 1 } else { 2 };
puts(a);
let b = if (false) { 3 } else { 4 };
puts(b);

let c = true
let d = if (a == 2) {
    puts("if");
    5;
} else {
    puts("else");
    6;
}

puts(d);
```
아래는 결과입니다. 
```monkey
1
4
else
6
```

블록문에서 가장 마지막 표현식이 값으로써 리턴됩니다. 아직까지 `else if`문은 지원하지 않으며 이는 추가 예정입니다. 

## fn 문

`monkey`에서 함수는 표현식입니다. Javascript에서 함수 표현식과 유사하며, `closure`를 지원합니다. 

```monkey
let fibonacci = fn(x) {
    if (x <= 1) {
        return 1;
    }
    return fibonacci(x - 1) + fibonacci(x - 2);
};

puts(fibonacci(10))

let make_fn = fn(x) {
    return fn(u) {
        return x + u;
    };
}

let my_fn = make_fn(3)
puts(my_fn(2))
```

아래는 결과입니다. 
```monkey
89
5
```

## for 문

`monkey`에서 `for`문 역시 표현식입니다. 하지만, `for`문이 반환하는 값은 `for`문 내부의 표현식이 아닌, `for`문 수행의 성공 여부입니다. 아래의 예시를 보는 것이 더 이해에 도움이 될 것입니다.

```monkey
let result1 = for (let i=0; i<10; i=i+1) { }
let result2 = for (let i=0; i<10; i=i+1) { break; }

puts(result1, result2)
```
```monkey
true
false
```

`break`외에도 `continue` 역시 사용 가능합니다. 


## TODO

위 추가 계획 외에도 추가하고 싶은 기능들이 많이 있습니다. 구현이 마냥 쉽지는 않아서 모두 다 할 수 있을지는 의문입니다만 그래도 생각하고 있는 것들을 나열해봅니다. 

- index기반 재할당 

현재 일반 변수의 재할당은 구현된 상태입니다만, `list` 혹은 `hash`에 `[]`로 접근하여 변수를 재할당하는 것은 구현하지 못했습니다. **AST**레벨에서 구현을 바꿔야할지, 평가 과정에서 구현을 바꿔야할지 여러가지 고민이 많습니다. 

- class

기본적인 객체를 설계하고 만들 수 있도록 하고자 하는 욕심이 있습니다. 아래와 같은 코드를 실행할 수 있도록 하고자 합니다. 

```monkey
let Monkey = class T {
    member x, y, z;
};

let obj = Monkey(1, 2, fn(x) { return x })
puts(obj.x, obj.y)
puts(obj.z(3))
```

```monkey
1
2
3
```

클래스 역시 표현식으로 만들고자 합니다. 이는 파이썬에서 `cmp_to_key` 메서드와 같은 패턴을 허용하기 위함입니다. 

- 함수형 프로그래밍

사실 함수형 프로그래밍에 대해 아는바가 깊지 않습니다. 현재 `ocaml`에 대해 공부 중이며 추후 서울대학교 이광근 교수님의 **프로그래밍 언어** 과제를 통해 언어 설계에 대해 좀더 지식을 얻고 진행하고자 합니다. 졸업한 이후 이 수업을 듣고 싶게 될 줄은.. 세상 일은 모르는 겁니다. 

일단 `monkey`는 일급 함수를 가지기 때문에 FP로의 확장이 가능할 것으로 기대합니다. 그 즈음엔 더 이상 `monkey`가 아니게 될지도 모르겠네요.

- 컴파일러 설계

현재 **밑바닥부터 만드는 컴파일러 in Go**를 통해 AST 노드를 바이트코드로 만들고, 이를 디코드하여 실행하는 방식으로 변경 중입니다. 책의 내용으로는 절반정도 진행되었습니다만, 이미 인터프리터를 어느정도 변형해놓은지라 이로인한 이슈는 피할 수 없을 듯 합니다. `monkey`가 조금 더 빠르게 작동할 수 있는 언어가 되기를 기대합니다. 

- `monkey` IDE

저자와 제가 만든 언어이기 때문에, 당연히 시중에 풀려있는 IDE는 없습니다. 토큰에 위치 정보를 추가하고, AST 노드를 해석하여 highlighing을 제공하고자 합니다. 또한 `builtin` 함수 등 자동완성을 지원하고자 생각 중입니다. 

형식은 고민 중인데, 마냥 생각만 하던 `VSCode Extension`을 설계하는 방법을 생각해보았고, 저만의 OJ(Online Judge)를 만들어서 내부 IDE에 지원하도록 하는 방안도 생각해보았습니다. 후자의 경우 이 언어를 설계하기 이전부터 프로젝트로써 고민해왔던지라, 아마 후자를 선택할 것 같긴 합니다. 

- host 언어의 가비지 콜렉터 제거

현재 `monkey` 언어는 host 언어인 Go의 가비지 콜렉터를 그대로 이용하고 있습니다. 이는 저자도 알고 있는 부분이고, 독자들에게 주는 과제라고 생각합니다. 가비지 콜렉터를 제거하고 자신만의 가비지 콜렉터를 만드는 것으로 생각 중입니다. 다만, Go 언어에서 메모리 할당 제거를 허용은 해주지만, 권장하고 있는 것은 아닌 것 같아 어떻게 해야할지 고민중입니다. 


- REPL 개선

현재는 if 문, for 문 등을 한 줄에 써야만 하는 번거로움이 있습니다. 이를 여러줄에 걸쳐 사용할 수 있도록 하는 방안을 고민 중입니다. 
